% !Mode::"TeX:UTF-8"

\begin{lstlisting}[language=C++, firstnumber=1]
#include<cstdio>
#include<cstring>
#include<string>
#include<sstream>
#include<iostream>
#include<windows.h>
using namespace std;
const int maxn=15;
const int Lens[15]={0,5,6,7,8,9,8,7,6,5};
int Map[maxn][maxn];
bool If_map[maxn][maxn];
const int Left[maxn][maxn]={
    {0},
    {0,1,2,3,4,5},
    {0,1,2,3,4,5,6},
    {0,1,2,3,4,5,6,7},
    {0,1,2,3,4,5,6,7,8},
    {0,1,2,3,4,5,6,7,8,9},
    {0,2,3,4,5,6,7,8,9},
    {0,3,4,5,6,7,8,9},
    {0,4,5,6,7,8,9},
    {0,5,6,7,8,9}
};
const int Right[maxn][maxn]={
    {0},
    {0,5,6,7,8,9},
    {0,4,5,6,7,8,9},
    {0,3,4,5,6,7,8,9},
    {0,2,3,4,5,6,7,8,9},
    {0,1,2,3,4,5,6,7,8,9},
    {0,1,2,3,4,5,6,7,8},
    {0,1,2,3,4,5,6,7},
    {0,1,2,3,4,5,6},
    {0,1,2,3,4,5}
};
bool Vis_Left[maxn][maxn],Vis_Right[maxn][maxn];
int Max_left[maxn],Min_left[maxn],Max_right[maxn],Min_right[maxn];
int F[11][410000][11];
int F_cnt[11];
int P[maxn];//排列
bool Vis[maxn];
void Dfs_pre(int cur,int Stax,int Stox,int Len){
    if(cur==Len){
        F_cnt[Len]++;
        for(int i=1;i<=Len;i++){
            F[Len][F_cnt[Len]][i]=P[i];
        }
        return;
    }
    for(int i=Stax;i<=Stox;i++){
        if(!Vis[i]){
            Vis[i]=true;
            P[cur+1]=i;
            Dfs_pre(cur+1,Stax,Stox,Len);
            Vis[i]=false;
            P[cur+1]=0;
        }
    }
    return;
}
void Pre(){
    for(int i=5;i<=9;i++){
        for(int j=1;j<=i-5+1;j++){
            if(i-j+1>=5){
                Dfs_pre(0,j,i,i-j+1);
            }
        }
    }
    return;
}
bool Flag_of_exit=false;
int s=0;
void Dfs_solve(int cur){
    if(Flag_of_exit){
        return;
    }
    if(cur>9){
        Flag_of_exit=true;
        cout<<endl;
        cout<<"`竟然蜂巢数独也被你解开了！！！`"<<endl;
        cout<<endl;
        for(int i=1;i<=9;i++){
            for(int j=1;j<=10-Lens[i];j++){
                cout<<" ";
            }
            for(int j=1;j<=Lens[i];j++){
                cout<<Map[i][j]<<"  ";
            }
            cout<<endl;
        }
        cout<<endl;
        cout<<endl;
        return;
    }
    bool Flag_of_ok=true;
    for(int i=1;i<=F_cnt[Lens[cur]];i++){
        Flag_of_ok=true;
        for(int j=1;j<=Lens[cur];j++){
            if(If_map[cur][j]&&Map[cur][j]!=F[Lens[cur]][i][j]){
                Flag_of_ok=false;
                break;
            }
            if(!If_map[cur][j]){
                if(Vis_Left[Left[cur][j]][F[Lens[cur]][i][j]]||Vis_Right[Right[cur][j]][F[Lens[cur]][i][j]]){
                    Flag_of_ok=false;
                    break;
                }
                if(F[Lens[cur]][i][j]<Max_left[Left[cur][j]]-Lens[Left[cur][j]]+1||F[Lens[cur]][i][j]>Min_left[Left[cur][j]]+Lens[Left[cur][j]]-1){
                    Flag_of_ok=false;
                    break;
                }
                if(F[Lens[cur]][i][j]<Max_right[Right[cur][j]]-Lens[Right[cur][j]]+1||F[Lens[cur]][i][j]>Min_right[Right[cur][j]]+Lens[Right[cur][j]]-1){
                    Flag_of_ok=false;
                    break;
                }
            }

        }
        if(!Flag_of_ok){
            continue;
        }
        int a[15],b[15],c[15],d[15];
        for(int j=1;j<=Lens[cur];j++){
            if(!If_map[cur][j]){
                Map[cur][j]=F[Lens[cur]][i][j];
                Vis_Left[Left[cur][j]][Map[cur][j]]=true;
                Vis_Right[Right[cur][j]][Map[cur][j]]=true;
                a[j]=Max_left[Left[cur][j]];
                b[j]=Max_right[Right[cur][j]];
                c[j]= Min_left[Left[cur][j]];
                d[j]=Min_right[Right[cur][j]];
                Max_left[Left[cur][j]]=max(Max_left[Left[cur][j]],Map[cur][j]);
                Max_right[Right[cur][j]]=max(Max_right[Right[cur][j]],Map[cur][j]);
                Min_left[Left[cur][j]]=min(Min_left[Left[cur][j]],Map[cur][j]);
                Min_right[Right[cur][j]]=min(Min_right[Right[cur][j]],Map[cur][j]);
            }
        }
        Dfs_solve(cur+1);
        for(int j=1;j<=Lens[cur];j++){
            if(!If_map[cur][j]){
                Vis_Left[Left[cur][j]][Map[cur][j]]=false;
                Vis_Right[Right[cur][j]][Map[cur][j]]=false;
                Max_left[Left[cur][j]]=a[j];
                Max_right[Right[cur][j]]=b[j];
                Min_left[Left[cur][j]]=c[j];
                Min_right[Right[cur][j]]=d[j];
                Map[cur][j]=0;
            }
        }
    }
    return;
}
int main(){
    memset(Max_left,-63,sizeof(Max_left));
    memset(Min_left,63,sizeof(Min_left));
    memset(Max_right,-63,sizeof(Max_right));
    memset(Min_right,63,sizeof(Min_right));
    for(int i=1;i<=9;i++){
        for(int pos=1;pos<=Lens[i];pos++){
            cin>>Map[i][pos];
            if(Map[i][pos]!=0){
                Vis_Left[Left[i][pos]][Map[i][pos]]=true;
                Vis_Right[Right[i][pos]][Map[i][pos]]=true;
                Max_left[Left[i][pos]]=max(Max_left[Left[i][pos]],Map[i][pos]);
                Max_right[Right[i][pos]]=max(Max_right[Right[i][pos]],Map[i][pos]);
                Min_left[Left[i][pos]]=min(Min_left[Left[i][pos]],Map[i][pos]);
                Min_right[Right[i][pos]]=min(Min_right[Right[i][pos]],Map[i][pos]);
                If_map[i][pos]=true;
            }
        }
    }
    Pre();
    Dfs_solve(1);
    return 0;
}
\end{lstlisting}
