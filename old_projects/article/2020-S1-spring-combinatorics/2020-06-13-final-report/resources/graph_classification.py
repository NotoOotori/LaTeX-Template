'''Calculate the number of graphs up to isomorphism with a fixed number of vertices.'''

from numpy.polynomial.polynomial import Polynomial, polyadd, polypow, polymul
from sympy.combinatorics import Permutation
from sympy.combinatorics.perm_groups import PermutationGroup


def get_edge_group(n: int):
    '''
    The permutation group of vertices is generated by 2 elements. Thus the
    induced permutation group of egdes is also generated by 2 elements.

    return: the permutation group of edges of class PermutationGroup

    parameters:
        n: the number of vertices.
    '''
    # Generators of permutation group of vertices.
    vertice_perms = [
        Permutation([[0, 1], [n - 1]]),
        Permutation([list(range(n))])]
    # Edges represented by a 2-list of vertice index with ascending order.
    # We use `list` instead of `tuple` just because the `sorted` function
    #  returns tuple objects.
    edges = [[i, j] for i in range(n) for j in range(n) if i < j]
    # Construct a list of two lists, each of which contains the image edges
    #  mapped by each permutation of the original order.
    image_edges_of_perms = [
        [sorted([perm(edge[0]), perm(edge[1])]) for edge in edges]
        for perm in vertice_perms]
    # Construct the generators of permutation group of edges by array notation.
    edge_perms = [
        Permutation([edges.index(edge) for edge in image_edges])
        for image_edges in image_edges_of_perms]
    # Construct the group by generators.
    group = PermutationGroup(edge_perms)
    return group

def compute_weight_ogf(n: int = 4):
    '''
    The main function.

    parameters:
        n: the number of vertices.
    '''
    group = get_edge_group(n)
    binom = int(n*(n-1)/2)
    # Generate functions f(x) = 1 + x, ..., f(x^n) = 1 + x^n.
    colour_ogfs = [Polynomial([1,] + i*[0,] + [1,]) for i in range(binom)]
    # We need to summand among all terms.
    weight_ogf = 0
    for perm in group._elements:
        cycles = [
            len([1 for cycle in perm.full_cyclic_form if len(cycle) == i + 1])
            for i in range(binom)]
        term = 1
        for i, colour_ogf in enumerate(colour_ogfs):
            term = term * (colour_ogf ** cycles[i])
        weight_ogf = weight_ogf + term
    weight_ogf = weight_ogf/group.order()
    return(weight_ogf)

def main():
    for n in range(2, 8):
        print('n: {}, total: {}, ogf: {}'.format(
            n, compute_weight_ogf(n)(1), compute_weight_ogf(n)))

if __name__ == "__main__":
    main()
