% !Mode::"TeX:UTF-8"

\begin{lstlisting}[language=C++, firstnumber=1, basicstyle=\tiny]
//Copyright @ 2018 tsp group
#include<cstdio>
#include<cstring>
#include<windows.h>
#include<iostream>
#include<cmath>
#define maxn 15
using namespace std;
const int Delta_big[15]={50,9,17,24,30,35,39,42,44,45};
const int Delta_small[15]={-50,1,3,6,10,15,21,28,36,45};
struct Node{
    int Flag_of_kind;
    int val;
    int Right;
    int Down;
    int vis;
    int Vis_right[15];
    int Vis_down[15];
    int rcnt;
    int rSum_now;
    int dSum_now;
    int dcnt;
    int Len_lr;
    int Len_ud;
    int Len_lr_no;
    int Len_ud_no;
    int Right_no;
    int Down_no;
}Map[maxn][maxn];
struct Message{
    int Len_lr;
    int Lx;
    int Len_ud;
    int Uy;
}Messages[maxn][maxn];
int Aim_cnt;
bool F[50][15][15];//F[i][j][k],把i分解成j组，k是否可以成为其分解
int F_max[50][15];//最大的
int F_min[50][15];//最小的
int Break_up[15];
//下列函数用来预处理
void Dfs_pre(int cur,int Last_num,int Sum_now,int Aim_num,int Aim_dep){
    if(Sum_now+(Aim_dep-cur)*9<Aim_num){
        return;
    }
    if(Sum_now+(Aim_dep-cur)>Aim_num){
        return;
    }
    if(cur==Aim_dep){
        if(Sum_now!=Aim_num){
            return;
        }
        else{
            for(int i=1;i<=Aim_dep;i++){
                F_max[Aim_num][Aim_dep]=max(F_max[Aim_num][Aim_dep],Break_up[i]);
                F_min[Aim_num][Aim_dep]=min(F_min[Aim_num][Aim_dep],Break_up[i]);
                F[Aim_num][Aim_dep][Break_up[i]]=true;
            }
            return;
        }
    }
    for(int i=Last_num+1;i<=9&&Sum_now+i<=Aim_num;i++){
        Break_up[cur+1]=i;
        Dfs_pre(cur+1,i,Sum_now+i,Aim_num,Aim_dep);
    }
    return;
}
void Pre(){
    for(int i=1;i<=45;i++){
        for(int j=1;j<=9;j++){
            Dfs_pre(0,0,0,i,j);
        }
    }
    for(int i=1;i<=10;i++){
        for(int j=1;j<=9;j++){
            F[0][i][j]=true;
            F_max[0][i]=1e6;
            F_min[0][i]=0;
        }
    }
    return;
}
inline int Check_false(){
    for(int i=1;i<=8;i++){
        for(int j=1;j<=10;j++){
            if(Map[i][j].Flag_of_kind==1||Map[i][j].Flag_of_kind==3){

                if(Map[i][j].Len_lr==0&&Map[i][j].Right!=0){
                    return 0;
                }
                if(Delta_big[(Map[i][j].Len_lr)]<Map[i][j].Right){
                    return -1;
                }
                if(Delta_small[(Map[i][j].Len_lr)]>Map[i][j].Right){
                    return -1;
                }
            }
            if(Map[i][j].Flag_of_kind==1||Map[i][j].Flag_of_kind==4){

                if(Map[i][j].Len_ud==0&&Map[i][j].Down!=0){
                    return 0;
                }
                if(Delta_big[(Map[i][j].Len_ud)]<Map[i][j].Down){
                    return -1;
                }
                if(Delta_small[(Map[i][j].Len_ud)]>Map[i][j].Down){
                    return -1;
                }

            }
        }
    }
    return 1;
}
int Cut_down_cnt=0;
inline int Cut_down(){
    for(int i=1;i<=8;i++){
        for(int j=1;j<=10;j++){
            if(Map[i][j].Flag_of_kind||Map[i][j].vis){
                continue;
            }
            int x=Messages[i][j].Lx,y=Messages[i][j].Uy;
            bool ok_tmp=false;
            for(int k=1;k<=9;k++){//以下是本文最重要的减枝
                if(F[Map[i][x].Right][Map[i][x].Len_lr][k]&&F[Map[y][j].Down][Map[y][j].Len_ud][k]&&!Map[i][x].Vis_right[k]&&!Map[y][j].Vis_down[k]){
                    if(k<=F_max[Map[i][x].Right_no][Map[i][x].Len_lr_no]&&k<=F_max[Map[y][j].Down_no][Map[y][j].Len_ud_no]){
                        if(k>=F_min[Map[i][x].Right_no][Map[i][x].Len_lr_no]&&k>=F_min[Map[y][j].Down_no][Map[y][j].Len_ud_no]){
                            if(Delta_big[Map[i][x].Len_lr-1]+k>=Map[i][x].Right&&Delta_small[Map[i][x].Len_lr-1]+k<=Map[i][x].Right){
                                if(Delta_big[Map[y][j].Len_ud-1]+k>=Map[y][j].Down&&Delta_small[Map[y][j].Len_ud-1]+k<=Map[y][j].Down){

                                    ok_tmp=true;
                                }
                            }
                        }
                    }
                }
            }
            if(!ok_tmp){

                return 0;
            }
        }
    }
    return 1;
}
int Cnt_all=0;
int Ans_cnt=0;
bool Flag_of_over=false;
void Dfs_solve(int scnt,int s1,int s2,int s3,int cc3){
	Cnt_all++;
    /*
	cout<<scnt<<endl;
    for(int i=1;i<=8;i++){
            for(int j=1;j<=10;j++){
                if(!Map[i][j].Flag_of_kind){
                    cout<<Map[i][j].val<<" ";
                }
                else{
                    cout<<"* ";
                }
            }
            cout<<endl;
        }
    Sleep(1000);
	*/
 	if(Flag_of_over){
        return;
    }
    if(Check_false()<=0){
        return;
    }
    if(!Cut_down()){
    	Cut_down_cnt++;
        return;
    }
    if(scnt==Aim_cnt){
        cout<<endl;
        cout<<"作为宇宙的统治者，你成功复原了此王之数独！！"<<endl<<endl;
        Flag_of_over=true;
       	Ans_cnt++;
        for(int i=1;i<=8;i++){
            for(int j=1;j<=10;j++){
                if(!Map[i][j].Flag_of_kind){
                    cout<<Map[i][j].val<<" ";
                }
                else{
                    cout<<"* ";
                }
            }
            cout<<endl;
        }
        cout<<endl;
        cout<<"(台下掌声)"<<endl;
        cout<<endl;
        cout<<"使用归谬策略的次数: "<<cc3<<endl;
        cout<<"搜索分支数(1,2,3): "<<s1<<" "<<s2<<" "<<s3<<endl;
        cout<<"难度系数："<<log(1*(1<<s2)*pow(3,s3)*cc3)<<endl;
        return;
    }

    for(int Times=1;Times<=9;Times++){
        bool Flag_of_next=false;
        for(int i=8;i>=1;i--){
            if(Flag_of_next){
                break;
            }
            for(int j=10;j>=1;j--){
                if(!Map[i][j].Flag_of_kind&&!Map[i][j].vis){
                    int cnt=0;
                    int c1=0,c2=0,c3=0;
                    int x=Messages[i][j].Lx,y=Messages[i][j].Uy;
                    for(int k=1;k<=9;k++){
                        if(F[Map[i][x].Right][Map[i][x].Len_lr][k]&&F[Map[y][j].Down][Map[y][j].Len_ud][k]&&!Map[i][x].Vis_right[k]&&!Map[y][j].Vis_down[k]){
                            if(Map[i][x].Flag_of_kind==1||Map[i][x].Flag_of_kind==3){
                                Map[i][x].rcnt++;
                                Map[i][x].rSum_now+=k;
                                Map[i][x].Vis_right[k]=true;
                                Map[i][x].Len_lr-=1;
                                Map[i][x].Right-=k;
                            }
                            if(Map[y][j].Flag_of_kind==1||Map[y][j].Flag_of_kind==4){
                                Map[y][j].dcnt++;
                                Map[y][j].dSum_now+=k;
                                Map[y][j].Vis_down[k]=true;
                                Map[y][j].Len_ud-=1;
                                Map[y][j].Down-=k;
                            }
                            Map[i][j].vis=true;
                            Map[i][j].val=k;
                            int ok1 = Check_false();
							int ok2 = Cut_down();
							if(ok1==0){
								c1++;
							}
							else if(ok1==-1){
		                        c2++;
							}
							else if(!ok2){
						 	    c3++;
							}
                            if(ok1>0&&ok2){
                                    cnt++;
							}
                            Map[i][j].vis=false;
                            Map[i][j].val=0;
                            if(Map[i][x].Flag_of_kind==1||Map[i][x].Flag_of_kind==3){//3表示只有右
                                Map[i][x].rcnt--;
                                Map[i][x].rSum_now-=k;
                                Map[i][x].Vis_right[k]=false;
                                Map[i][x].Len_lr+=1;
                                Map[i][x].Right+=k;

                            }
                            if(Map[y][j].Flag_of_kind==1||Map[y][j].Flag_of_kind==4){//4表示只有下
                                Map[y][j].dcnt--;
                                Map[y][j].dSum_now-=k;
                                Map[y][j].Vis_down[k]=false;
                                Map[y][j].Len_ud+=1;
                                Map[y][j].Down+=k;
                            }
                        }
                    }
                    if(cnt==Times){
                        for(int k=9;k>=1;k--){
                            if(F[Map[i][x].Right][Map[i][x].Len_lr][k]&&F[Map[y][j].Down][Map[y][j].Len_ud][k]&&!Map[i][x].Vis_right[k]&&!Map[y][j].Vis_down[k]){
                                if(Map[i][x].Flag_of_kind==1||Map[i][x].Flag_of_kind==3){
                                    Map[i][x].rcnt++;
                                    Map[i][x].rSum_now+=k;
                                    Map[i][x].Vis_right[k]=true;
                                    Map[i][x].Len_lr-=1;
                                    Map[i][x].Right-=k;
                                }
                                if(Map[y][j].Flag_of_kind==1||Map[y][j].Flag_of_kind==4){
                                    Map[y][j].dcnt++;
                                    Map[y][j].dSum_now+=k;
                                    Map[y][j].Vis_down[k]=true;
                                    Map[y][j].Len_ud-=1;
                                    Map[y][j].Down-=k;
                                }
                                Map[i][j].vis=true;
                                Map[i][j].val=k;
                                if(Times==1){
                                	Dfs_solve(scnt+1,s1+1,s2,s3,cc3+c3);
								}
								else if(Times==2){
									 Dfs_solve(scnt+1,s1,s2+1,s3,cc3+c3);
								}
								else{
									Dfs_solve(scnt+1,s1,s2,s3+1,cc3+c3);
								}


                                Map[i][j].vis=false;
                                Map[i][j].val=0;
                                if(Map[i][x].Flag_of_kind==1||Map[i][x].Flag_of_kind==3){//3表示只有右
                                    Map[i][x].rcnt--;
                                    Map[i][x].rSum_now-=k;
                                    Map[i][x].Vis_right[k]=false;
                                    Map[i][x].Len_lr+=1;
                                    Map[i][x].Right+=k;

                                }
                                if(Map[y][j].Flag_of_kind==1||Map[y][j].Flag_of_kind==4){//4表示只有下
                                    Map[y][j].dcnt--;
                                    Map[y][j].dSum_now-=k;
                                    Map[y][j].Vis_down[k]=false;
                                    Map[y][j].Len_ud+=1;
                                    Map[y][j].Down+=k;
                                }
                            }
                        }
                        return;
                    }
                }
            }
        }
    }
    return;
}
int main(){
    int flag;
    int x,y;
    memset(Map,0,sizeof(Map));
    memset(F_max,0,sizeof(F_max));
    memset(F_min,63,sizeof(F_max));
    int s=0;
    while(cin>>flag){//1表示有约束
        if(!flag){
            break;
        }
        s++;
        cin>>x>>y;
        Map[x][y].Flag_of_kind=flag;
        cin>>Map[x][y].Right;
        Map[x][y].Right_no=Map[x][y].Right;
        cin>>Map[x][y].Down;
        Map[x][y].Down_no=Map[x][y].Down;
    }

    Aim_cnt=80-s;
    for(int i=1;i<=8;i++){
        Map[i][0].Flag_of_kind=2;
        Map[i][11].Flag_of_kind=2;
    }
    for(int i=1;i<=10;i++){
        Map[0][i].Flag_of_kind=2;
        Map[9][i].Flag_of_kind=2;
    }
    for(int i=1;i<=9;i++){
        F[i][1][i]=true;
    }
    Pre();

    for(int i=1;i<=8;i++){
        for(int j=1;j<=10;j++){
            if(!Map[i][j].Flag_of_kind){
                int x1=j,x2=j,y1=i,y2=i;
                while(!Map[i][x1].Flag_of_kind){
                    x1--;
                }
                while(!Map[i][x2].Flag_of_kind){
                    x2++;
                }
                while(!Map[y1][j].Flag_of_kind){
                    y1--;
                }
                while(!Map[y2][j].Flag_of_kind){
                    y2++;
                }
                Messages[i][j].Lx=x1;
                Messages[i][j].Uy=y1;
                Messages[i][j].Len_lr=x2-x1-1;
                Messages[i][j].Len_ud=y2-y1-1;
                if(Map[i][x1].Flag_of_kind==1||Map[i][x1].Flag_of_kind==3){
                    Map[i][x1].Len_lr=Map[i][x1].Len_lr_no=Messages[i][j].Len_lr;
                }
                if(Map[y1][j].Flag_of_kind==1||Map[y1][j].Flag_of_kind==4){
                    Map[y1][j].Len_ud=Map[y1][j].Len_ud_no=Messages[i][j].Len_ud;
                }
            }
        }
    }
	Dfs_solve(0,0,0,0,0);
    cout<<"该数独共有"<<Ans_cnt<<"组解"<<endl;
    cout<<"共计算了"<<Cnt_all<<"次"<<endl;
    return 0;
}
\end{lstlisting}
